---
name: model-selection
description: 작업 특성에 따라 최적의 AI 모델(Haiku/Sonnet/Opus)을 선택합니다.
version: 1.0.0
author: The Forge
tags: [core, optimization, strategist]
---

# 모델 선택 스킬 (Model Selection)

## 목적

모든 작업을 고성능 모델(Opus)에 맡기면 **비용과 시간이 낭비**됩니다.
작업의 복잡도와 특성에 따라 **적절한 모델을 배치**하여 효율을 극대화합니다.

---

## 모델별 특성

| 모델 | 강점 | 약점 | 비용 | 속도 |
|------|------|------|:----:|:----:|
| **Haiku** | 빠른 속도, 저비용 | 복잡한 추론 약함 | $ | ⚡⚡⚡ |
| **Sonnet** | 균형잡힌 성능 | 극도로 복잡한 작업 | $$ | ⚡⚡ |
| **Opus** | 최고 수준 추론 | 비용, 속도 | $$$ | ⚡ |

---

## 선택 기준

### 🟢 Haiku 적합 작업

```
- 단순 탐색/검색
- 패턴 매칭
- 데이터 파싱
- 형식 변환
- 코드 포매팅
- 단순 반복 작업
```

**예시**:
- 코드베이스에서 특정 패턴 찾기
- JSON 구조 파싱
- 로그 파일 분석
- 간단한 텍스트 변환

### 🟡 Sonnet 적합 작업

```
- 일반적인 코드 작성
- 문서 생성
- 에이전트/스킬 생성
- API 설계
- 버그 수정
- 리팩토링
```

**예시**:
- React 컴포넌트 작성
- API 엔드포인트 구현
- 에이전트 .md 파일 생성
- 중간 복잡도 디버깅

### 🔴 Opus 적합 작업 (신중하게!)

```
- 복잡한 아키텍처 설계
- 다중 시스템 통합 전략
- 고난도 알고리즘 설계
- 전략적 의사결정
```

**예시**:
- 마이크로서비스 아키텍처 설계
- 복잡한 비즈니스 로직 설계
- 시스템 전체 리팩토링 전략

---

## 선택 알고리즘

```
입력: task (작업 정보)

1. 복잡도 점수 계산
   - 기능 수: +10점/개
   - 의존성 수: +5점/개
   - 도메인 수: +15점/개
   - 예상 토큰: +1점/1000토큰

2. 작업 유형 가중치
   - 탐색/검색: ×0.5
   - 생성/작성: ×1.0
   - 설계/전략: ×1.5

3. 최종 점수 → 모델 매핑
   - 0~30점: Haiku
   - 31~70점: Sonnet
   - 71점+: Opus (사용자 확인 필요)
```

---

## 출력 스키마

```json
{
  "task_id": "T1",
  "task_name": "API 엔드포인트 스캔",
  "complexity_score": 25,
  "breakdown": {
    "function_count": 2,
    "dependency_count": 1,
    "domain_count": 1,
    "estimated_tokens": 5000,
    "task_type_multiplier": 0.5
  },
  "selected_model": "haiku",
  "reasoning": "단순 탐색 작업으로 Haiku가 적합",
  "alternatives": [
    {
      "model": "sonnet",
      "when": "정확도가 중요한 경우"
    }
  ],
  "cost_estimate": {
    "haiku": "$0.002",
    "sonnet": "$0.015",
    "opus": "$0.075"
  }
}
```

---

## 배치 예시

### 예시: API 테스트 에이전트 생성

```json
{
  "tasks": [
    {
      "id": "T1",
      "name": "코드베이스 스캔",
      "selected_model": "haiku",
      "reasoning": "단순 파일 탐색"
    },
    {
      "id": "T2",
      "name": "테스트 케이스 생성",
      "selected_model": "sonnet",
      "reasoning": "코드 작성 필요"
    },
    {
      "id": "T3",
      "name": "전체 테스트 전략 수립",
      "selected_model": "sonnet",
      "reasoning": "중간 복잡도 설계"
    }
  ],
  "total_cost_estimate": {
    "all_haiku": "$0.006",
    "optimized": "$0.032",
    "all_sonnet": "$0.045",
    "all_opus": "$0.225"
  },
  "savings": "최적화로 29% 비용 절감"
}
```

---

## 병렬 실행 전략

```
Haiku 에이전트의 강점: 동시에 여러 개 실행 가능

예시:
- Sonnet 1개로 분석: 30초, $0.045
- Haiku 5개 병렬로 분석: 8초, $0.010

→ 속도 3.75배 향상, 비용 78% 절감
```

### 병렬화 권장 패턴

| 작업 유형 | 권장 | 이유 |
|----------|------|------|
| 파일별 분석 | Haiku ×N 병렬 | 독립적, 단순 |
| 모듈별 검사 | Haiku ×N 병렬 | 독립적, 반복적 |
| 코드 생성 | Sonnet 순차 | 의존성 있음 |
| 통합 검증 | Sonnet 순차 | 전체 맥락 필요 |

---

## Opus 사용 시 주의사항

```
⚠️ Opus는 다음 경우에만 사용:

1. 복잡도 점수 70점 이상
2. 여러 도메인에 걸친 전략적 결정
3. Sonnet으로 2회 이상 실패한 작업

🚫 Opus 사용 전 반드시 사용자 확인!
```

---

## 비용 최적화 팁

1. **탐색은 항상 Haiku**: 코드 읽기, 검색은 Haiku로 충분
2. **생성은 Sonnet**: 코드/문서 작성은 Sonnet이 적절
3. **병렬화 적극 활용**: 독립적인 작업은 Haiku 병렬로
4. **Opus는 최후의 수단**: 정말 필요할 때만

---

## 주의사항

- 모델 선택은 **제안**이며 최종 결정은 strategist가 수행
- 비용 추정치는 **대략적인 값**이며 실제와 다를 수 있음
- Opus 선택 시 반드시 **사용자 확인** 필요
